--- 
title: DEMO of Replicating Ledoit and Wolf (2008, 2011) Functions
author: "Paulo Ferreira Naibert" 
output: 
  html_document:
    toc: false
    number_sections: true
keep_tex: true
bibliography: refs.bib
--- 

Original: 2019 October 13.

Current: `r format(Sys.time(), "%d, %B, %Y")`

# Overview
The goal of this DEMO to verify if the repository replicates the functions on Michael Wolf's website.

I didn't have time to replicate the `block.size.calibrate()` functions.

The ORIGINAL codes can be found in 
[Michael Wolf's Webpage](https://www.econ.uzh.ch/en/people/faculty/wolf.html), 
in the 
[publications section](https://www.econ.uzh.ch/en/people/faculty/wolf/publications.html).


# Differences in the Functions on Each File

First let's take a look on which funs the files share.

```{r}
# Funs in "Shape.RData"
load("./R/Sharpe.RData");
sr <- ls();
rm(list=setdiff(ls(), "sr"))
sr

# Funs in "./R/Var.RData"
load("./R/Var.RData");
lv <- setdiff(ls(), "sr");
rm(list=setdiff(ls(), c("sr", "lv"))); 
lv

# Shared functions on files
intersect(sr, lv)

# Function on SR but not in Var
setdiff(sr, lv)

# Function on Var but not in SR
setdiff(lv, sr)

# Funs in "./R/LW-SR.Var.R"
source("./R/LW-SR-VAR.R"); my <- setdiff(ls(), c("sr","lv") )
my

# Shared functions on files
intersect(my, sr)
intersect(my, lv)

# remove all funs
rm(list=ls())
```
So I just didn't change the name of `kernel.Parzen()`


# Data and Functions

First, let's check if there are not any loaded objects

```{r}
ls()
```

Now we load the data and check it.

```{r}
# Load Data
ret <- readRDS("./DATA/rets.RDS")
str(ret)
```

Only now do we load the functions.

```{r}
# Load my functions
source("./R/LW-SR-VAR.R");

# Load LW functions
load("./R/Var.RData"); load("./R/Sharpe.RData");
```

#  HAC INFERENCE

Here, and in the next sections, we use the `all.equal()` function with argument `check.names` set to `FALSE`.
Now let's look if the output of the functions are different.

## Sharpe Ratio

Starting with the Sharpe Ratio:

```{r}
tmp1 <- unlist(hac.inference(ret$hedge)); tmp1
tmp2 <- unlist(sr.hac.test(ret$hedge, pw=0)); tmp2
tmp3 <- unlist(sr.hac.test(ret$hedge, pw=1)); tmp3
```

### Test SR HAC

```{r}
all.equal(tmp1["Difference"], tmp2["Diff"], check.names=FALSE)
all.equal(tmp1["Difference"], tmp3["Diff"], check.names=FALSE)

all.equal(tmp1["Standard.Errors.HAC"], tmp2["se"], check.names=FALSE)
all.equal(tmp1["Standard.Errors.HAC.pw"], tmp3["se"], check.names=FALSE)

all.equal(tmp1["p.Values.HAC"], tmp2["p.value"], check.names=FALSE)
all.equal(tmp1["p.Values.HAC.pw"], tmp3["p.value"], check.names=FALSE)
```

The differences are on the 4th decimal place.
The difference might be due to the `round()` function.
On the original functions this value is set with `round(,3)`.

## Variances

Now, the variances:

```{r}
tmp1 <- unlist(hac.inference.log.var(ret$hedge)); tmp1
tmp2 <- unlist(var.hac.test(ret$hedge, pw=0)); tmp2
tmp3 <- unlist(var.hac.test(ret$hedge, pw=1)); tmp3
```

### Test Var HAC

```{r}
all.equal(tmp1["Difference"], tmp2["Diff"], check.names=FALSE)
all.equal(tmp1["Difference"], tmp3["Diff"], check.names=FALSE)

all.equal(tmp1["Standard.Errors.HAC"], tmp2["se"], check.names=FALSE)
all.equal(tmp1["Standard.Errors.HAC.pw"], tmp3["se"], check.names=FALSE)

all.equal(tmp1["p.Values.HAC"], tmp2["p.value"], check.names=FALSE)
all.equal(tmp1["p.Values.HAC.pw"], tmp3["p.value"], check.names=FALSE)
```

When there are differences, they are at most on the 4th decimal place.
This might be due to the `round()` function.
On `Var.RData` this value is set with `round(,3)`

# BOOT TIME SERIES INFERENCE

Now we turn to the Inference using Bootstrap.
We first use the `set.seed()` function.
The reasons for doing so is twofold:
(a) so we can repeat our experiment, and (b) so the output of the functions are comparable.

Then, we evaluate the difference in the Sharpe Ratio, again using the `all.equal()` function.

## Sharpe Ratio
```{r}
set.seed(1)
t0 <- Sys.time()
tmp1 <- boot.time.inference(ret$hedge, b=5, M=499)
t1 <- Sys.time(); t1-t0
tmp1

set.seed(1)
t0 <- Sys.time()
tmp2 <- sr.boot.test(ret$hedge,  b=5, M=499)
t1 <- Sys.time(); t1-t0
tmp2

```

### Test SR boot
```{r}
all.equal(tmp1["Difference"], tmp2["Diff"], check.names=FALSE)
all.equal(tmp1["p.Value"], tmp2["p.value"], check.names=FALSE)
```

The output of the test indicates difference in the `Difference` argument only on the 4th decimal place.
The `p.value` is equal.

## Variance

Finally, we check the output of the function that performs boostrap inference in the variance.

```{r}
set.seed(1)
t0 <- Sys.time()
tmp1 <- unlist(boot.time.inference.log.var(ret$hedge, b=5, M=499))
t1 <- Sys.time(); t1-t0
tmp1

set.seed(1)
t0 <- Sys.time()
tmp2 <- unlist(var.boot.test(ret$hedge, b=5, M=499)); tmp2
t1 <- Sys.time(); t1-t0
```

### Test Var boot

```{r}
all.equal(tmp1["Difference"], tmp2["Diff"], check.names=FALSE)
all.equal(tmp1["p.Value"], tmp2["p.value"], check.names=FALSE)
```

The output of the test indicates difference in the `Difference` argument only on the 4th decimal place.
The `p.value` is equal.


# Software Information
```{r}
sessionInfo()
```

# DISCLAIMER

I own NONE of the rights to the codes.
I simply edited the already existing codes in
[Michael Wolf's Webpage](https://www.econ.uzh.ch/en/people/faculty/wolf.html).
I also offer NO support for the functions.
They are presented AS IS.
