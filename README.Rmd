--- 
title: "Replicating Ledoit and Wolf (2008, 2011) Functions" 
date: '`r format(Sys.time(), "%d, %B, %Y")`'
author: "Paulo Ferreira Naibert" 
output: 
  html_document:
    toc: false
    number_sections: true
keep_tex: true
bibliography: refs.bib
--- 


# Introduction

On @lw2008-sr and @lw2011-var, the authors provide a method to test the hypothesis of difference in the Sharpe Ratio and the Variance of two investment strategies.
The papers can be found in the following links:

[SR Paper](https://www.econ.uzh.ch/dam/jcr:ffffffff-935a-b0d6-0000-00007214c2bc/jef_2008pdf.pdf), 
[SR WP](http://www.econ.uzh.ch/static/wp_iew/iewwp320.pdf), 
[Variance Paper](https://www.econ.uzh.ch/dam/jcr:520edf26-2322-4708-8dde-51d61141914a/Ledoit_et_al-2011-Wilmott_Robust_Performance.pdf), 
[Variance WP](http://www.econ.uzh.ch/static/wp_iew/iewwp516.pdf).

In this post we are going to replicate @lw2008-sr and @lw2011-var.
The codes can be found in 
[Michael Wolf's Webpage](https://www.econ.uzh.ch/en/people/faculty/wolf.html), 
in the 
[publications section](https://www.econ.uzh.ch/en/people/faculty/wolf/publications.html).
Our goal is to verify if I replicated the functions on Michael Wolf's website.
On what follows is a test of the functions' outputs.

## Functions

I copied the original functions on `Sharpe.RData` and `Var.RData` into the files: `"./SR-ORIGINAL.R"` and `"./Var-ORIGINAL.R"` with some minor modifications.
Then I copied the functions to the file `"./MYfuns.R"` and modified them more.


## Data

For the data, I simpy saved the returns data of `Sharpe.RData` as a `.RDS` file.
The following code should work:

```{r, eval=FALSE}
load("Sharpe.RData")
lwret <- list("mutual"=as.matrix(ret.agg), "hedge"=ret.hedge)
saveRDS(lwret, "./rets.RDS")
```

Loading `rets.RDS` should result in a list object on the `R` Software [@R] .


# Functions on Each File

First let's take a look on which funs the files share.

```{r}
# Differences in the funs

# Funs in "./SR-ORIGINAL.R"
source("./SR-ORIGINAL.R");
sr <- ls();
rm(list=setdiff(ls(), "sr"))
sr

# Funs in "./Var-ORIGINAL.R"
source("./Var-ORIGINAL.R");
lv <- setdiff(ls(), "sr");
rm(list=setdiff(ls(), c("sr", "lv"))); 
lv

# Shared functions on files
intersect(sr, lv)

# Function on SR but not in Var
setdiff(sr, lv)

# Function on Var but not in SR
setdiff(lv, sr)

# Funs in "./MYfuns.R"
source("./MYfuns.R"); my <- setdiff(ls(), c("sr","lv") )
my

# Shared functions on files
intersect(my, sr)
intersect(my, lv)

# remove all funs
rm(list=ls())
```
So I just didn't change the name of `kernel.Parzen()`


# Data and Functions

First, let's check if there are not any loaded objects

```{r}
ls()
```

Now we load the data and check it.

```{r}
# Load Data
ret <- readRDS("./rets.RDS")
str(ret)
```

Only now do we load the functions.

```{r}
# Load my functions
source("./MYfuns.R")

# Load LW functions
source("./SR-ORIGINAL.R"); source("./Var-ORIGINAL.R");
```

#  HAC INFERENCE

Here, and in the next sections, we use the `all.equal()` function with argument `check.names` set to `FALSE`.
Now let's look if the output of the functions are different.

## Sharpe Ratio

Starting with the Sharpe Ratio:

```{r}
tmp1 <- hac.inf.sr(ret$hedge, est="sr")
tmp2 <- hac.inference(ret$hedge)

tmp1; tmp2; all.equal(tmp1, tmp2, check.names=FALSE)
```

The only difference is on component 4.
This is the $p$-Values object.
The difference is on the 4th decimal place.
The difference might be due to the `round()` function.
On `SR-ORIGINAL.R` this value is set with `round(,3)`

## Variances

Now, the variances:

```{r}
tmp1 <- hac.inf.var(ret$hedge, est="var")
tmp2 <- hac.inference.log.var(ret$hedge)

tmp1; tmp2; all.equal(tmp1, tmp2, check.names=FALSE)
```

All outputs are different: `Variances` `Log.Variances` `Difference` `Standard.Errors` and `p.Values`
However, we can note the the differences are only on the 4th decimal place.
This might be due to the `round()` function.
On `Var-ORIGINAL.R` this value is set with `round(,3)`

# BOOT TIME SERIES INFERENCE

Now we turn to the Inference using Bootstrap.
We first set a seed.
The reasons for doing so is twofold:
(a) so we can repeat our experiment, and (b) so the output of the functions are comparable.

```{r}
# Set seed so results are comparable
set.seed(1)
```

Then, we evaluate the difference in the Sharpe Ratio, again using the `all.equal()` function.

## Sharpe Ratio
```{r}
# tmp1 <- boot.inf.sr(ret$hedge, est="sr", b=5, M=499)
# tmp2 <- boot.time.inference(ret$hedge, b=5, M=499)
# 
# tmp1; tmp2; all.equal(tmp1, tmp2, check.names=FALSE)
```

We can note that we have a difference in the p-values of the Sharpe Ratios.
This might be due to the small sample correction $T/(T-4)$ on the `Psi.Star` quantity that I introduced in my code, but not on LW's.

## Variance

Finally, we check the output of the function that performs boostrap inference in the variance.

```{r}
# tmp1 <- boot.inf.var(ret$hedge, est="var", b=5, M=499)
# tmp2 <- boot.time.inference.log.var(ret$hedge, b=5, M=499)
# 
# tmp1; tmp2; all.equal(tmp1, tmp2, check.names=FALSE)
```

The output of the `all.equal()` function is `TRUE` which indicates that all quantities are equal.


# System Information

## Software Information
```{r}
sessionInfo()
```

# DISCLAIMER

I own NONE of the rights to the codes.
I simply edited the already existing codes in
[Michael Wolf's Webpage](https://www.econ.uzh.ch/en/people/faculty/wolf.html).
I also offer NO support for the functions.
They are presented AS IS.

# REFERENCES
